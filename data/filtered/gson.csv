,comment1,comment2,name1,name2,meta1,meta2,label
0,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->",1
1,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->",1
2,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsNumber,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->",1
3,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsNumber,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->",1
4,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->",1
5,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
6,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
7,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
8,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsNumber,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
9,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->",1
10,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsString,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->",1
11,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsString,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->",1
12,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->",1
13,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
14,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
15,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
16,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsString,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
17,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsDouble,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->",1
18,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsDouble,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->",1
19,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.",getAsDouble,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->",1
20,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsDouble,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
21,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsDouble,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
22,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsDouble,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
23,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsDouble,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
24,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2",getAsBigDecimal,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->",1
25,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.",getAsBigDecimal,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->",1
26,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsBigDecimal,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
27,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsBigDecimal,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
28,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsBigDecimal,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
29,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsBigDecimal,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
30,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.",getAsBigInteger,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->",1
31,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsBigInteger,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
32,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsBigInteger,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
33,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsBigInteger,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
34,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsBigInteger,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
35,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.",getAsFloat,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->",1
36,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsFloat,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
37,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsFloat,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
38,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsFloat,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
39,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.",getAsLong,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->",1
40,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsLong,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
41,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsLong,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
42,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.",getAsInt,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->",1
43,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsInt,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
44,"convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.",getAsShort,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->",1
45,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.",getAsJsonObject,getAsJsonArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->",1
46,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.",getAsJsonObject,getAsJsonPrimitive,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->",1
47,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.",getAsJsonArray,getAsJsonPrimitive,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->",1
48,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ",getAsBoolean,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->",1
49,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->",1
50,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->",1
51,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",1
52,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->",1
53,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
54,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
55,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsBoolean,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
56,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsBoolean,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
57,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->",1
58,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->",1
59,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",1
60,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->",1
61,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
62,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBooleanWrapper,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
63,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsBooleanWrapper,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
64,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsBooleanWrapper,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
65,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsNumber,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->",1
66,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsNumber,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",1
67,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsNumber,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->",1
68,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsNumber,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
69,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsNumber,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
70,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsNumber,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
71,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsNumber,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
72,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsString,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",1
73,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsString,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->",1
74,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsString,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
75,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsString,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
76,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsString,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
77,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsString,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
78,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsDouble,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->",1
79,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsDouble,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
80,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsDouble,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
81,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsDouble,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
82,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsDouble,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
83,"convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsFloat,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",1
84,"convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsFloat,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
85,"convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsFloat,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
86,"convenience method to get this element as a primitive float value.
 @return get this element as a primitive float value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 float value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsFloat,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
87,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsLong,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",1
88,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsLong,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
89,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsLong,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
90,"convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsInt,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",1
91,"convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsInt,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
92,"convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsByte,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",1
93,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2",getAsBigDecimal,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->",1
94,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",DateTypeAdapter,SqlDateTypeAdapter,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->",1
95,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","Adapter for Time. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",DateTypeAdapter,TimeTypeAdapter,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""TimeTypeAdapter"", ""entityFile"": ""TimeTypeAdapter.java""} -->",1
96,"Convenience method to get the specified member as a JsonPrimitive element.
 @param memberName name of the member being requested.
 @return the JsonPrimitive corresponding to the specified member.","Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.",getAsJsonPrimitive,getAsJsonArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",1
97,"Convenience method to get the specified member as a JsonPrimitive element.
 @param memberName name of the member being requested.
 @return the JsonPrimitive corresponding to the specified member.","Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.",getAsJsonPrimitive,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",1
98,"Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.","Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.",getAsJsonArray,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",1
99,"This method serializes the specified object into its equivalent representation as a tree of
 {@link JsonElement}s. This method should be used when the specified object is not a generic
 type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 the {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJsonTree(Object, Type)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.
 @since 1.4","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.",toJsonTree,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->",1
100,"This method serializes the specified object, including those of generic types, into its
 equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
 specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
 instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}
 @since 1.4","This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}",toJsonTree,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->",1
101,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",toJson,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",1
102,"This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT","This method deserializes the Json read from the specified reader into an object of the
 specified class. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
 {@link Reader}, use {@link #fromJson(String, Class)} instead.
 @param <T> the type of the desired object
 @param json the reader producing the Json from which the object is to be deserialized.
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException"", ""entityFile"": ""Gson.java""} -->",1
103,"This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",1
104,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",1
105,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",1
106,"This method deserializes the Json read from the specified reader into an object of the
 specified class. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
 {@link Reader}, use {@link #fromJson(String, Class)} instead.
 @param <T> the type of the desired object
 @param json the reader producing the Json from which the object is to be deserialized.
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",1
107,"This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",1
108,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current array.",beginArray,endArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
109,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.","Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.",beginArray,beginObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
110,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.",beginArray,endObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
111,"Consumes the next token from the JSON stream and asserts that it is the
 end of the current array.","Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.",endArray,beginObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
112,"Consumes the next token from the JSON stream and asserts that it is the
 end of the current array.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.",endArray,endObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
113,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.",beginObject,endObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
114,"Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",nextString,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
115,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",nextDouble,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
116,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as an int. If the next token's numeric value cannot be exactly
 represented by a Java {@code int}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as an int.",nextDouble,nextInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int nextInt() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
117,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as an int. If the next token's numeric value cannot be exactly
 represented by a Java {@code int}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as an int.",nextLong,nextInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int nextInt() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",1
118,"The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.","The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.",BEGIN_ARRAY,END_ARRAY,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",1
119,"The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",BEGIN_ARRAY,BEGIN_OBJECT,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",1
120,"The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.","The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.",BEGIN_ARRAY,END_OBJECT,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",1
121,"The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",END_ARRAY,BEGIN_OBJECT,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",1
122,"The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.","The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.",END_ARRAY,END_OBJECT,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",1
123,"The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.","The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.",BEGIN_OBJECT,END_OBJECT,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",1
124,"Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern","Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3",setFieldNamingPolicy,setFieldNamingStrategy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->",1
125,"Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param style the predefined date style that date objects will be serialized/deserialized
 to/from
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",setDateFormat,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int style)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",1
126,"Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","Adapter for Time. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",SqlDateTypeAdapter,TimeTypeAdapter,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""TimeTypeAdapter"", ""entityFile"": ""TimeTypeAdapter.java""} -->",1
127,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",getAsBooleanWrapper,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
128,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",getAsBooleanWrapper,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
129,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a String.
 @return get this element as a String.",getAsBooleanWrapper,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
130,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",getAsBooleanWrapper,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
131,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsBooleanWrapper,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
132,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsBooleanWrapper,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
133,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsBooleanWrapper,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
134,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsBooleanWrapper,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
135,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsBooleanWrapper,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
136,"convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsBooleanWrapper,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
137,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",getAsBoolean,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
138,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a String.
 @return get this element as a String.",getAsBoolean,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
139,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",getAsBoolean,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
140,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsBoolean,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
141,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsBoolean,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
142,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsBoolean,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
143,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsBoolean,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
144,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsBoolean,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
145,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsBoolean,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
146,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a String.
 @return get this element as a String.",getAsNumber,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
147,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",getAsNumber,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
148,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsNumber,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
149,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsNumber,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
150,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsNumber,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
151,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsNumber,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
152,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsNumber,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
153,"convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsNumber,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
154,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",getAsString,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
155,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsString,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
156,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsString,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
157,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsString,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
158,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsString,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
159,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsString,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
160,"convenience method to get this element as a String.
 @return get this element as a String.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsString,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
161,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsDouble,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
162,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsDouble,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
163,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsDouble,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
164,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsDouble,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
165,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsDouble,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
166,"convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsDouble,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
167,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsBigDecimal,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
168,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsBigDecimal,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
169,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsBigDecimal,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
170,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsBigDecimal,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
171,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsBigDecimal,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
172,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsBigInteger,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
173,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsBigInteger,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
174,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsBigInteger,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
175,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsBigInteger,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
176,"convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsFloat,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
177,"convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsFloat,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
178,"convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsFloat,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
179,"convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsLong,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
180,"convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsLong,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
181,"convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsShort,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",1
182,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type",getAsString,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
183,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Adapter for Time. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",getAsBigDecimal,TimeTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""TimeTypeAdapter"", ""entityFile"": ""TimeTypeAdapter.java""} -->",0
184,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.",getAsBigInteger,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",0
185,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.",getAsBigDecimal,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->",0
186,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",getAsInt,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
187,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",getAsBoolean,SqlDateTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->",0
188,"This method serializes the specified object into its equivalent representation as a tree of
 {@link JsonElement}s. This method should be used when the specified object is not a generic
 type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 the {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJsonTree(Object, Type)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.
 @since 1.4","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",toJsonTree,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
189,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","This method serializes the specified object, including those of generic types, into its
 equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
 specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
 instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}
 @since 1.4",DateTypeAdapter,toJsonTree,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->",0
190,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",getAsString,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
191,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsBigDecimal,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
192,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsDouble,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
193,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2",getAsJsonObject,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->",0
194,"convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",getAsCharacter,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
195,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",toJson,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
196,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",getAsLong,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
197,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsLong,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
198,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsJsonArray,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",0
199,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",fromJson,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
200,"convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",getAsInt,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
201,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.",fromJson,BEGIN_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
202,"Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",setDateFormat,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
203,"This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",fromJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
204,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",toJson,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
205,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.",fromJson,BEGIN_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
206,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",nextLong,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
207,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param style the predefined date style that date objects will be serialized/deserialized
 to/from
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsBigDecimal,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int style)"", ""entityFile"": ""GsonBuilder.java""} -->",0
208,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsString,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
209,"convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",getAsShort,BEGIN_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
210,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",getAsJsonArray,BEGIN_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
211,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as an int. If the next token's numeric value cannot be exactly
 represented by a Java {@code int}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as an int.",getAsString,nextInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int nextInt() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
212,"convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type",getAsCharacter,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
213,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param style the predefined date style that date objects will be serialized/deserialized
 to/from
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsBigInteger,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int style)"", ""entityFile"": ""GsonBuilder.java""} -->",0
214,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBigInteger,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",0
215,"The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",END_ARRAY,getAsDouble,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
216,"convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",getAsShort,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
217,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.",fromJson,nextString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
218,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",getAsNumber,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
219,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",getAsNumber,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
220,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",getAsLong,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
221,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",getAsBigInteger,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
222,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.",getAsJsonObject,beginArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
223,"Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",endObject,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
224,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",nextDouble,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
225,"Convenience method to get the specified member as a JsonPrimitive element.
 @param memberName name of the member being requested.
 @return the JsonPrimitive corresponding to the specified member.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.",getAsJsonPrimitive,endObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
226,"convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.",getAsByte,END_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
227,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","convenience method to get this element as a primitive double.
 @return get this element as a primitive double.
 @throws NumberFormatException if the value contained is not a valid double.",fromJson,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
228,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",nextDouble,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
229,"convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.",getAsCharacter,END_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
230,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsBigInteger,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
231,"convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.",getAsInt,getAsJsonArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",0
232,"Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",setFieldNamingPolicy,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
233,"Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",getAsJsonObject,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
234,"Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsJsonArray,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
235,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","This method serializes the specified object, including those of generic types, into its
 equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
 specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
 instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}
 @since 1.4",getAsBigDecimal,toJsonTree,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->",0
236,"This method serializes the specified object into its equivalent representation as a tree of
 {@link JsonElement}s. This method should be used when the specified object is not a generic
 type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 the {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJsonTree(Object, Type)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.
 @since 1.4","This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type",toJsonTree,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
237,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",toJson,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
238,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",getAsInt,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
239,"convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->",0
240,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",getAsBigDecimal,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
241,"convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element is not a valid {@link BigInteger}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT",getAsBigInteger,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
242,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",getAsBigDecimal,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
243,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsDouble,getAsCharacter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->",0
244,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",beginArray,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
245,"convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",getAsByte,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
246,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.",getAsBigDecimal,BEGIN_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
247,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBigInteger,getAsDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->",0
248,"convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsBooleanWrapper,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
249,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2",getAsJsonArray,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->",0
250,"The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",END_OBJECT,getAsBoolean,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
251,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.",getAsLong,getAsJsonPrimitive,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->",0
252,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsInt,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->",0
253,"Convenience method to get the specified member as a JsonPrimitive element.
 @param memberName name of the member being requested.
 @return the JsonPrimitive corresponding to the specified member.","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",getAsJsonPrimitive,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
254,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",getAsBigInteger,DateTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->",0
255,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.",getAsNumber,nextDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
256,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT",getAsBigDecimal,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
257,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","The closing of a JSON object. Written using {@link JsonWriter#endObject}
 and read using {@link JsonReader#endObject}.",getAsJsonObject,END_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
258,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsJsonObject,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
259,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",fromJson,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
260,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsLong,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
261,"The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",BEGIN_OBJECT,getAsBigDecimal,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
262,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method serializes the specified object into its equivalent representation as a tree of
 {@link JsonElement}s. This method should be used when the specified object is not a generic
 type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 the {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJsonTree(Object, Type)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.
 @since 1.4",getAsLong,toJsonTree,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src)"", ""entityFile"": ""Gson.java""} -->",0
263,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3",toJson,setFieldNamingStrategy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->",0
264,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}",DateTypeAdapter,toJson,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->",0
265,"Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",nextString,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
266,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",fromJson,BEGIN_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
267,"convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",getAsInt,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
268,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",toJson,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
269,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",getAsInt,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
270,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",toJson,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
271,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type",getAsLong,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
272,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsNumber,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
273,"This method serializes the specified object, including those of generic types, into its
 equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
 specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
 instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}
 @since 1.4","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",toJsonTree,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
274,"convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsByte,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
275,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.",getAsLong,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->",0
276,"Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",setFieldNamingStrategy,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
277,"Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",nextString,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
278,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current array.",toJson,endArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
279,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",getAsInt,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
280,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3",getAsJsonObject,getAsByte,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->",0
281,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3",getAsInt,setFieldNamingStrategy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->",0
282,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",fromJson,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
283,"The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",END_ARRAY,setFieldNamingPolicy,"<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
284,"This method serializes the specified object into its equivalent representation as a tree of
 {@link JsonElement}s. This method should be used when the specified object is not a generic
 type. This method uses {@link Class#getClass()} to get the type for the specified object, but
 the {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJsonTree(Object, Type)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.
 @since 1.4","The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.",toJsonTree,END_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
285,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",fromJson,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
286,"convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param style the predefined date style that date objects will be serialized/deserialized
 to/from
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsNumber,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int style)"", ""entityFile"": ""GsonBuilder.java""} -->",0
287,"convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBoolean,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->",0
288,"This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT","convenience method to get this element as a String.
 @return get this element as a String.",fromJson,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
289,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","convenience method to get this element as a float.
 @return get this element as a float.
 @throws NumberFormatException if the value contained is not a valid float.",toJson,getAsFloat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
290,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.",toJson,nextString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
291,"Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",nextString,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
292,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.",toJson,nextDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
293,"Convenience method to get the specified member as a JsonPrimitive element.
 @param memberName name of the member being requested.
 @return the JsonPrimitive corresponding to the specified member.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",getAsJsonPrimitive,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
294,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsBigInteger,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
295,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",getAsLong,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
296,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsInt,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
297,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsString,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
298,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsInt,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->",0
299,"Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",endObject,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
300,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",getAsBigInteger,getAsShort,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
301,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",getAsLong,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
302,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",toJson,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
303,"convenience method to get this array as a boolean if it contains a single element.
 @return get this element as a boolean if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid boolean.
 @throws IllegalStateException if the array has more than one element.","The closing of a JSON array. Written using {@link JsonWriter#endArray}
 and read using {@link JsonReader#endArray}.",getAsBoolean,END_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""END_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
304,"This method deserializes the specified Json into an object of the specified type. This method
 is useful if the specified object is a generic type. For non-generic objects, use
 {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Type)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonParseException if json is not a valid representation for an object of type typeOfT
 @throws JsonSyntaxException if json is not a valid representation for an object of type","Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.",fromJson,beginObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
305,"convenience method to get this array as a {@link BigInteger} if it contains a single element.
 @return get this element as a {@link BigInteger} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBigInteger,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->",0
306,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.",getAsLong,nextDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
307,"Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",getAsJsonArray,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
308,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",getAsBigDecimal,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
309,"convenience method to get this array as an integer if it contains a single element.
 @return get this element as an integer if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid integer.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsInt,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->",0
310,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.",toJson,beginArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
311,"convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsShort,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
312,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","Adapter for Time. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",toJson,TimeTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""TimeTypeAdapter"", ""entityFile"": ""TimeTypeAdapter.java""} -->",0
313,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Adapter for Time. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",getAsString,TimeTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""TimeTypeAdapter"", ""entityFile"": ""TimeTypeAdapter.java""} -->",0
314,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.",getAsLong,BEGIN_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
315,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.",getAsFloat,getAsJsonPrimitive,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->",0
316,"convenience method to get this array as a float if it contains a single element.
 @return get this element as a float if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid float.
 @throws IllegalStateException if the array has more than one element.","Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3",getAsFloat,setFieldNamingStrategy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public float getAsFloat()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->",0
317,"This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",fromJson,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
318,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a double using {@link Double#parseDouble(String)}.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a double, or is non-finite.",toJson,nextDouble,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double nextDouble() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
319,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.",getAsJsonArray,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->",0
320,"convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",getAsBoolean,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
321,"Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @param writer Writer to which the Json representation needs to be written
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2",getAsJsonObject,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->",0
322,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",toJson,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
323,"convenience method to get this array as a {@link BigDecimal} if it contains a single element.
 @return get this element as a {@link BigDecimal} if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.
 @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the array has more than one element.
 @since 1.2","convenience method to get this element as a {@link Number}.
 @return get this element as a {@link Number}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 number.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsBigDecimal,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonElement.java""} -->",0
324,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a primitive integer value.
 @return get this element as a primitive integer value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 integer value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsJsonObject,getAsInt,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonElement.java""} -->",0
325,"Configures Gson to apply a specific naming policy strategy to an object's field during
 serialization and deserialization.
 @param fieldNamingStrategy the actual naming strategy to apply to the fields
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.3","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",setFieldNamingStrategy,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy)"", ""entityFile"": ""GsonBuilder.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
326,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",DateTypeAdapter,BEGIN_OBJECT,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
327,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out
 the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}","Consumes the next token from the JSON stream and asserts that it is the
 end of the current array.",toJson,endArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
328,"Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.","convenience method to get this element as a {@link Boolean}.
 @return get this element as a {@link Boolean}.
 ",getAsJsonArray,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
329,"convenience method to get this element as a primitive double value.
 @return get this element as a primitive double value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 double value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsDouble,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
330,"This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",toJson,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
331,"convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.","Configures Gson to apply a specific naming policy to an object's field during serialization
 and deserialization.
 @param namingConvention the JSON field naming convention to use for serialization and
 deserialization.
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern",getAsJsonPrimitive,setFieldNamingPolicy,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention)"", ""entityFile"": ""GsonBuilder.java""} -->",0
332,"convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",getAsJsonPrimitive,BEGIN_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
333,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new array.","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",beginArray,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginArray() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
334,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.",getAsLong,getAsJsonArray,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->",0
335,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","The opening of a JSON array. Written using {@link JsonWriter#beginArray}
 and read using {@link JsonReader#beginArray}.",toJson,BEGIN_ARRAY,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_ARRAY"", ""entityFile"": ""JsonToken.java""} -->",0
336,"Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","convenience method to get this element as a primitive short.
 @return get this element as a primitive short.
 @throws NumberFormatException if the value contained is not a valid short value.",SqlDateTypeAdapter,getAsShort,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
337,"convenience method to get this element as a string value.
 @return get this element as a string value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 string value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method deserializes the Json read from the specified parse tree into an object of the
 specified type. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(JsonElement, Type)}.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param classOfT The class of T
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3",getAsString,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
338,"Adapter for Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.","convenience method to get this element as a primitive integer.
 @return get this element as a primitive integer.
 @throws NumberFormatException if the value contained is not a valid integer.",DateTypeAdapter,getAsInt,"<!-- META {""entityType"": ""Class"", ""entitySignature"": ""DateTypeAdapter"", ""entityFile"": ""DateTypeAdapter.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int getAsInt()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
339,"convenience method to get this array as a {@link String} if it contains a single element.
 @return get this element as a String if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid String.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.",getAsString,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->",0
340,"Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",nextBoolean,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
341,"Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as an int. If the next token's numeric value cannot be exactly
 represented by a Java {@code int}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as an int.","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",nextInt,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public int nextInt() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
342,"This method serializes the specified object, including those of generic types, into its
 equivalent representation as a tree of {@link JsonElement}s. This method must be used if the
 specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}
 instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return Json representation of {@code src}
 @since 1.4","Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",toJsonTree,SqlDateTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonElement toJsonTree(Object src, Type typeOfSrc)"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->",0
343,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",getAsLong,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
344,"Convenience method to get the specified member as a JsonArray.
 @param memberName name of the member being requested.
 @return the JsonArray corresponding to the specified member.","Consumes the next token from the JSON stream and asserts that it is the
 end of the current object.",getAsJsonArray,endObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void endObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
345,"convenience method to get this element as a primitive byte value.
 @return get this element as a primitive byte value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 byte value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","convenience method to get this element as a String.
 @return get this element as a String.",getAsByte,getAsString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public byte getAsByte()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String getAsString()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
346,"convenience method to get this array as a primitive short if it contains a single element.
 @return get this element as a primitive short if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid short.
 @throws IllegalStateException if the array has more than one element.","This method serializes the specified object into its equivalent Json representation.
 This method should be used when the specified object is not a generic type. This method uses
 {@link Class#getClass()} to get the type for the specified object, but the
 {@code getClass()} loses the generic type information because of the Type Erasure feature
 of Java. Note that this method works fine if the any of the object fields are of generic type,
 just the object itself should not be of a generic type. If the object is of generic type, use
 {@link #toJson(Object, Type)} instead. If you want to write out the object to a
 {@link Writer}, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which Json representation is to be created setting for Gson
 @return Json representation of {@code src}.",getAsShort,toJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public short getAsShort()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String toJson(Object src)"", ""entityFile"": ""Gson.java""} -->",0
347,"This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","convenience method to get this element as a primitive long.
 @return get this element as a primitive long.
 @throws NumberFormatException if the value contained is not a valid long.",fromJson,getAsLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
348,"Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.","Configures Gson to to serialize {@code Date} objects according to the style value provided.
 You can call this method or {@link #setDateFormat(String)} multiple times, but only the last
 invocation will be used to decide the serialization format.
 <p>Note that this style value should be one of the predefined constants in the
 {@code DateFormat} class. See the documentation in {@link java.text.DateFormat} for more
 information on the valid style constants.</p>
 @param dateStyle the predefined date style that date objects will be serialized/deserialized
 to/from
 @param timeStyle the predefined style for the time portion of the date objects
 @return a reference to this {@code GsonBuilder} object to fulfill the ""Builder"" pattern
 @since 1.2",getAsJsonObject,setDateFormat,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public GsonBuilder setDateFormat(int dateStyle, int timeStyle)"", ""entityFile"": ""GsonBuilder.java""} -->",0
349,"This method deserializes the specified Json into an object of the specified class. It is not
 suitable to use if the specified class is a generic type since it will not have the generic
 type information because of the Type Erasure feature of Java. Therefore, this method should not
 be used if the desired type is a generic type. Note that this method works fine if the any of
 the fields of the specified object are generics, just the object itself should not be a
 generic type. For the cases when the object is of generic type, invoke
 {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
 a String, use {@link #fromJson(Reader, Class)} instead.
 @param <T> the type of the desired object
 @param json the string from which the object is to be deserialized
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 classOfT","The opening of a JSON object. Written using {@link JsonWriter#beginObject}
 and read using {@link JsonReader#beginObject}.",fromJson,BEGIN_OBJECT,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""EnumConstant"", ""entitySignature"": ""BEGIN_OBJECT"", ""entityFile"": ""JsonToken.java""} -->",0
350,"This method deserializes the Json read from the specified parse tree into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
 @param <T> the type of the desired object
 @param json the root of the parse tree of {@link JsonElement}s from which the object is to
 be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.
 @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
 @since 1.3","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",fromJson,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
351,"convenience method to get this element as a {@link JsonPrimitive}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonPrimitive()}
 first.
 @return get this element as a {@link JsonPrimitive}.
 @throws IllegalStateException if the element is of another type.","Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.",getAsJsonPrimitive,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonPrimitive getAsJsonPrimitive()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",0
352,"convenience method to get this element as a {@link JsonObject}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonObject()}
 first.
 @return get this element as a {@link JsonObject}.
 @throws IllegalStateException if the element is of another type.","convenience method to get this element as a {@link Boolean} value.
 @return get this element as a {@link Boolean} value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 boolean value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 ",getAsJsonObject,getAsBooleanWrapper,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""Boolean getAsBooleanWrapper()"", ""entityFile"": ""JsonElement.java""} -->",0
353,"convenience method to get this element as a primitive character value.
 @return get this element as a primitive char value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 char value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.3","Convenience method to get the specified member as a JsonObject.
 @param memberName name of the member being requested.
 @return the JsonObject corresponding to the specified member.",getAsCharacter,getAsJsonObject,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public char getAsCharacter()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonObject getAsJsonObject(String memberName)"", ""entityFile"": ""JsonObject.java""} -->",0
354,"convenience method to get this array as a double if it contains a single element.
 @return get this element as a double if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid double.
 @throws IllegalStateException if the array has more than one element.","Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,
 consuming it.
 @throws IllegalStateException if the next token is not a boolean or if
 this reader is closed.",getAsDouble,nextBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public double getAsDouble()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean nextBoolean() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
355,"convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
 * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.
 @since 1.2","Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,
 consuming it. If the next token is a number, this method will return its
 string form.
 @throws IllegalStateException if the next token is not a string or if
 this reader is closed.",getAsBigDecimal,nextString,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public String nextString() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
356,"convenience method to get this element as a {@link JsonArray}. If the element is of some
 other type, a {@link IllegalStateException} will result. Hence it is best to use this method
 after ensuring that this element is of the desired type by calling {@link #isJsonArray()}
 first.
 @return get this element as a {@link JsonArray}.
 @throws IllegalStateException if the element is of another type.","This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",getAsJsonArray,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public JsonArray getAsJsonArray()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
357,"This method serializes the specified object, including those of generic types, into its
 equivalent Json representation. This method must be used if the specified object is a generic
 type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
 @param src the object for which JSON representation is to be created
 @param typeOfSrc The specific genericized type of src. You can obtain
 this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,
 to get the type for {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @param writer Writer to which the Json representation of src needs to be written.
 @throws JsonIOException if there was a problem writing to the writer
 @since 1.2","Adapter for java.sql.Date. Although this class appears stateless, it is not.
 DateFormat captures its time zone and locale when it is created, which gives
 this class state. DateFormat isn't thread safe either, so this class has
 to synchronize its read and write methods.",toJson,SqlDateTypeAdapter,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Class"", ""entitySignature"": ""SqlDateTypeAdapter"", ""entityFile"": ""SqlDateTypeAdapter.java""} -->",0
358,"convenience method to get this array as a long if it contains a single element.
 @return get this element as a long if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid long.
 @throws IllegalStateException if the array has more than one element.","convenience method to get this element as a {@link BigInteger}.
 @return get this element as a {@link BigInteger}.
 @throws NumberFormatException if the value contained is not a valid {@link BigInteger}.",getAsLong,getAsBigInteger,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigInteger getAsBigInteger()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
359,"This method deserializes the Json read from the specified reader into an object of the
 specified class. It is not suitable to use if the specified class is a generic type since it
 will not have the generic type information because of the Type Erasure feature of Java.
 Therefore, this method should not be used if the desired type is a generic type. Note that
 this method works fine if the any of the fields of the specified object are generics, just the
 object itself should not be a generic type. For the cases when the object is of generic type,
 invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
 {@link Reader}, use {@link #fromJson(String, Class)} instead.
 @param <T> the type of the desired object
 @param json the reader producing the Json from which the object is to be deserialized.
 @param classOfT the class of T
 @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2","convenience method to get this element as a {@link BigDecimal}.
 @return get this element as a {@link BigDecimal}.
 @throws NumberFormatException if the value contained is not a valid {@link BigDecimal}.",fromJson,getAsBigDecimal,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException"", ""entityFile"": ""Gson.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public BigDecimal getAsBigDecimal()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
360,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.","Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,
 consuming it. If the next token is a string, this method will attempt to
 parse it as a long. If the next token's numeric value cannot be exactly
 represented by a Java {@code long}, this method throws.
 @throws IllegalStateException if the next token is not a literal value.
 @throws NumberFormatException if the next literal value cannot be parsed
 as a number, or exactly represented as a long.",beginObject,nextLong,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long nextLong() throws IOException"", ""entityFile"": ""JsonReader.java""} -->",0
361,"Consumes the next token from the JSON stream and asserts that it is the
 beginning of a new object.","convenience method to get this element as a Number.
 @return get this element as a Number.
 @throws NumberFormatException if the value contained is not a valid Number.",beginObject,getAsNumber,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public void beginObject() throws IOException"", ""entityFile"": ""JsonReader.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
362,"convenience method to get this element as a primitive long value.
 @return get this element as a primitive long value.
 @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid
 long value.
 @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
 more than a single element.","This method deserializes the Json read from the specified reader into an object of the
 specified type. This method is useful if the specified object is a generic type. For
 non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
 String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.
 @param <T> the type of the desired object
 @param json the reader producing Json from which the object is to be deserialized
 @param typeOfT The specific genericized type of src. You can obtain this type by using the
 {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
 {@code Collection<Foo>}, you should use:
 <pre>
 Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
 </pre>
 @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
 @throws JsonIOException if there was a problem reading from the Reader
 @throws JsonSyntaxException if json is not a valid representation for an object of type
 @since 1.2",getAsLong,fromJson,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public long getAsLong()"", ""entityFile"": ""JsonElement.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException"", ""entityFile"": ""Gson.java""} -->",0
363,"convenience method to get this array as a {@link Number} if it contains a single element.
 @return get this element as a number if it is single element array.
 @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and
 is not a valid Number.
 @throws IllegalStateException if the array has more than one element.()","convenience method to get this element as a boolean value.
 @return get this element as a primitive boolean value.",getAsNumber,getAsBoolean,"<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public Number getAsNumber()"", ""entityFile"": ""JsonArray.java""} -->","<!-- META {""entityType"": ""Method"", ""entitySignature"": ""public boolean getAsBoolean()"", ""entityFile"": ""JsonPrimitive.java""} -->",0
